/// <reference types="node" />
import { Transform, TransformOptions } from 'stream';
export interface SplitterOptions extends TransformOptions {
    split?: string;
}
/**
Splitter is a stream.Transform that rechunks a stream into sub-buffers.
The output (readable) part is set to objectMode true, and emits Buffer objects.
The input (writable) part should be plain buffers (have no encoding).

By default, it splits on the universal newline (\r, \r\n, or \n).
The split byte can be specified in the options.

_writableState.decodeStrings defaults to true, so we should get Buffers
regardless of what's pushed in. If `opts.decodeStrings` is set to `false`,
the behavior is undefined. (TODO: force decodeStrings: true maybe?)

In other words, the Splitter should have the following values:

    {
      _writableState: {
        decodeStrings: true,
        objectMode: false
      },
      _readableState: {
        objectMode: true
      }
    }

*/
/**
A splitter stream rechunks a stream at every `split` byte, if `split` is defined.
If `split` is not defined, it will split at the universal newline (\r, \r\n, or \n).

_writableState.decodeStrings = true
_writableState.objectMode = false
_readableState.objectMode = true

Node.js 'stream' API calls _transform and _flush:
  _transform calls _advance:
    _advance calls flushBuffer (maybe multiple times)
      flushBuffer calls push()
  _flush calls flushBuffer, either once or not at all
    flushBuffer calls push()

*/
export declare class Splitter extends Transform {
    protected _buffer: Buffer;
    protected _encoding: any;
    constructor(options?: SplitterOptions);
    /** calling this will call toString on all emitted chunks, instead of
    returning buffers. */
    setEncoding(encoding: any): this;
    /** flushBuffer handles what we do to each split part */
    protected flushBuffer(buffer: any): void;
    /** _advance handles how we decide where the split points are */
    _advance(buffer: any): any;
    /**
    `encoding` describes the type of `chunk` -- if the _writableState.decodeStrings option is
    true, this will be useful; otherwise, `chunk` will be just a buffer, or if
    objectMode is true, it'll be an arbirary object, and `encoding` will just be
    'buffer'.
    */
    _transform(chunk: any, encoding: string, callback: (error?: Error, outputChunk?: any) => void): void;
    _flush(callback: any): void;
}
